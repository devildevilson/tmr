#ifndef ENTITY_AI_H
#define ENTITY_AI_H

#include "UserDataComponent.h"
#include "EventComponent.h"

#include "Utility.h"

#include <unordered_set>
#include <unordered_map>

class AIGroup;
class vertex_t;
class edge_t;
class EntityAI;
class StateController;
class MovementComponent;
class AbilityComponent;
class InventoryComponent;
class WeaponsComponent;
class AttributeComponent;
class EffectComponent;
class AttribChangeData;
namespace yacs {
  class entity;
}

enum class entity_type {
  player,
  npc,
  decoration,
  wall
};

// скорее всего синхронизация не нужна
// struct StateFlagsContainer {
//   uint32_t container;
//   
//   StateFlagsContainer();
//   
//   bool isBlocking() const;
//   bool isBlockingMovement() const;
//   bool hasPath() const;
//   bool isOnGround() const;
//   
//   // полюбому добавится еще много чего
//   
//   void setBlocking(const bool value);
//   void setBlockingMovement(const bool value);
//   void setPathExisting(const bool value);
//   void setOnGround(const bool value);
// };

// тут по идее также поведенческое дерево
  
//StateController* states; // пригодится чтобы узнать текущее состояние
//AttributeContainer* attributes; // атрибуты всегда могут потребоваться
//Vertex* vertex; // вершина (ну точнее то на чем мы сейчас стоим)

// указатель на локальные эвенты

// также у нас должны быть указатели на данные восприятия
// то есть мы должны взять коллизию, пересечение лучей
// и еще какие данные
// в коллизии наверное имеет смысл указать только колизию с ии объектами
// пересечение лучей для видимости 

// нужно наверное еще сделать какую-нибудь проверку на то достиг ли энтити конца пути?
// вообще, какие то вещи еще можно сделать отправкой эвентов, но это скорее всего капец душно
// путь по идее это общие данные, и наверное можно вытащить его сюда

// нужно также подумать о сне, чтобы не вызывать все эти вещи безовсякого смысла
// сон означает что нужно вызывать проверки не отсюда
// то есть попадание в область видимости или распространение звука 

// короче видимо рейкастинга совсем не избежать, но его можно значительно порезать
// как? во первых кастить вне конуса видимости не имеет смысла
// кастить после некоторого расстояния не имеет смысла
// кастить в определенных игровых условиях (например когда монстр в засаде) не имеет смысла
// кастить можно на несколько объектов сразу
// цель можно выдавать и без этих инсинуаций (например опять же при засаде, цель выдается если игрок наступил на какую-ниудь платформу)
// таким образом можно очень сильно сократить реальную необходимость кастить лучи

// что со звуком? тут проще, так как звук это по сути сферический триггер путешествующий с игроком
// триггерим и дело с концом

// неплохая идея возвращать running при отправке эвента вызывающего то же действие что и сейчас происходит
// например отправляем ховл в первый раз, начинаем анимацию, отправляем ховл во второй раз, ничего не делаем получаем running

class Blackboard {
public:
  union Data {
    const void* ptr;
    double valueF;
    size_t value;
  };
  
  void setPtr(const Type &id, const void* ptr);
  void setValueF(const Type &id, const double &value);
  void setValue(const Type &id, const size_t &value);
  
  const void* getPtr(const Type &id) const;
  double getValueF(const Type &id) const;
  size_t getValue(const Type &id) const;
private:
  std::unordered_map<Type, Data> map;
};

class EntityAI {
public:
  struct CreateInfo {
    entity_type entType;
    float r;
    vertex_t* m_vertex;
    yacs::entity* ent;
  };
  EntityAI(const CreateInfo &info);
  ~EntityAI();
  
  // теперь мы возвращаем компоненты действий которых хотим совершить
  // + функция pickup где то здесь должна находиться
  // все действия делаем с помощью этих компонентов
  
  void target(const EntityAI* target);
  bool pickup(const EntityAI* obj); // тут потребуется взять указатель на энтити, придется указатель приводить к не конст... а может и нет
  
  // должна быть функция отвечающая за смерть
  // как она должна выглядеть?
  // должна ли она принимать стейт? 
  // как определить нужно ли мне удалять энтити полностью 
  // либо можно только сократить память который он занимает
  // либо ничего не делать только стейт сменить?
  // стейт сменить я могу и так, нужно наверное только функцию слип какую нибудь сделать
  // наверное я могу выделить два состояния энтити: полное удаление и частичная чистка
  void removeSelf(const bool fullRemove = false);
  
  void sleep(const size_t &time = SIZE_MAX); // пропускаем несколько кадров, SIZE_MAX - пропускаем до того как нас подымут
  // как заставлять энтити проснуться? я думаю что через эвент "use", нужно тогда наверное разделить "use" и "awake"
  // в этом случае конечно удобнее оповещать все компоненты через эвент
  // точнее не все а те что мы использовали
  
  void addTag(const Type &type); // нужно ли добавлять теги из других источников?
  void removeTag(const Type &type);
  
  Blackboard & blackboard();
  
  MovementComponent* movement();
  AbilityComponent* actions();
  StateController* state();
  const InventoryComponent* inventory() const;
  const WeaponsComponent* weapons() const;
  const AttributeComponent* attributes() const;
  const EffectComponent* effects() const;
  const StateController* state() const;
  
  const EntityAI* target() const;
  bool hasTarget() const;
  
  simd::vec4 position() const;
  simd::vec4 direction() const;
  simd::vec4 scale() const;
  simd::vec4 velocity() const;
  float radius() const;
  
  const vertex_t* vertex() const;
  
  bool hasGroup() const;
//   bool isGroupAI() const;
  bool isGroupChief() const;
  const AIGroup* group() const;
  // еще мы наверное должны вернуть какой-то групповой статус
  
  // тут скорее всего еще что-то должно быть для бектрекинга
  // найти энтити по тому что у меня есть я смогу, но смогу ли я сделать другие вещи?
  // опять же мне сейчас быстро ничего в голову не приходит, и на мой взгляд этих данных достаточно
  // для тех задач, которые у меня будут
  
  // еще потребуется какой-нибудь быстрый тип (игрок, монстр, декорация, стена)
  entity_type entityType() const;
  
  // еще наверное в будущем пригодится ориентация в графе (вообще когда я получаю вершину, я получаю возможность ориентироваться в графе)
  // + скорее всего нужно добавить метод который соберет все объекты вокруг
  std::vector<const EntityAI*> getObjectsInRadius(const float &radius) const; // стоит эту функцию сделать с учетом быстрого типа
  std::vector<const EntityAI*> getObjectsInRadius(const entity_type &type, const float &radius) const;
  // какая еще ориентация в графе нужна?
  
  // коллизия, что я должен вернуть в коллизии? лучше всего работать только с EntityAI (и наверное потом придется сделать враппер для луа)
  // следовательно я должен каким то образом обойти коллизию, в поисках объектов с которыми у меня есть коллизия
  // какие физические данные их мне пригодятся? я могу получить случайно ступеньку и мне нужно будет как то определить что это именно ступенька
  const EntityAI* getNextCollider(size_t &index) const;
  
  // что с видимостью? как проверить? лучше всего это конечно луч кинуть, 
  // нужно еще чекнуть попадает ли в пирамиду видимости, но скорее всего это будет просто угол
  // как лучше всего это сделать? (проверки на пирамиду видимости, проверки на дальность, и в конце концов рейкастинг)
  // в принципе было бы полезно делать разные проверки физики, что находится в радиусе, лучи
  // TODO: физика обнуляет результаты каждый кадр, мне нужно чтобы данные оставались по крайней мере updateDelta (DELTA_TIME_CONSTANT)
  uint32_t rayCast(const simd::vec4 &pos, const simd::vec4 &dir, const float &dist) const;
  const EntityAI* nextRayCollider(const uint32_t &rayIndex, size_t &index) const;
  
  // нужно еще данные о том кто нас атаковал (нужно собственно атаку сделать)
  // по идее это мы можем получить из аттрибутов, но там та же проблема - данные чистятся каждое некоторое время
  // видимо необходимо сделать кольцевой буфер фиксированного размера (какого?), либо можно запоминать сколько данных добавлено было
  const AttribChangeData* getAttributeChange(const Type &type, size_t &index) const;
  
  // данные о звуках (звук это триггер, как его получить?)
  // звук должен распространяться по вершинам графа, стены блокируют звук 100% (то есть если нет в графе соединений, то и звук туда не дойдет)
  
  // возможно мне пригодится выдать какой нибудь тэг энтити
  // например, чтобы легко определить игрока или легко определить сторону
  bool hasTag(const Type &tag) const;
  
  bool grounded() const;
  
  const yacs::entity* getEntity() const;
protected:
  // так ли нам необходимо держать здесь pos, dir, vel?
  // первостепенной необходимости в этом нет, но это поможет обеспечить локальность данных
  // вообще это пригодится еще для группового ии
  
  // неоходимо держать их не в симде понятное дело
  float pos[4];
  float dir[4];
  float vel[4];
  
  uint32_t objectIndex; // этот индекс мне нужен для того чтобы определить пересечения
  
  entity_type entType;
  float r;
  vertex_t* m_vertex;
  vertex_t* lastVertex;
  
  const EntityAI* targetPtr;
  AIGroup* groupPtr;

//   UserDataComponent* usrData; // стоит ли возвращать его в EntityAI?
//   
//   MovementComponent* mv;
//   AbilityComponent* abilityComponent;
//   InventoryComponent* inventoryComponent;
//   WeaponsComponent* weaponsComponent;
//   AttributeComponent* attribs;
//   EffectComponent* effectsComp;
//   StateController* states;
  yacs::entity* ent;
  
  std::unordered_set<Type> tags;
  Blackboard localBlackboard;
};

// слот в группе, использоваться должен для того чтобы отделить одного актора группы от другого
// в том плане, чтобы они не перекрывали друг другу дорогу
// группа должна расчитать положение слотов в конечной точке, и исходя из этого направить энтити
// передвижение будет осуществлятся в соответствии этим слотам, 
// по этим слотам так же нужно вычислить формацию войск
// с формациями сложнее, не знаю как их представить...
// как бы так сделать, чтобы это потом можно было бы размножить на любое количество слотов?
// у любой формации есть несколько одинаковых признаков: количество энтити в одной линии, 
// (количество линий вычисляется на основе этого, да и предыдущий параметр может быть вычислен на основе количества энтити)
// тут скорее правила вычисления линии, тип при свинье у нас первая линия меньше, остальные одинаковы
// при клине у нас первая линия из одного, остальные +1 больше
// нашел текст, который предлагает ввести виртуального лидера для поддержки формации
// а формацию придется видимо сделать с помощью интерфейсов

// короче пехотных строев выделяют 3 типа
// фаланга (линейный строй) (первый ряд полный - далее сужается), клин (первый ряд не полный, далее расширяется), рассыпной строй
// мы можем отсюда выделить несколько общих штук:
// максимальное количество человек в ряду
// сужение строя (чаще всего за счет отсутствующих членов отряда)
// колонны - это не очень полезный инструмент
// расстояние между челиками в строю

// статья предлагает еще возвращать центроид, проще скорее всего перевычислить

// в моем случае формация должна выполнять строго утилити функции
// конечная цель формации задать вектор движения для всех челиков в строю
// 

struct FormationSlot {
  EntityAI* entity; // const? скорее всего нет, как иначе передавать положение куда идти?
  uint32_t row;
  uint32_t rowIndex;
  // позиция к которой он стремится? скорее всего ее нужно вычислять от некоего головного челика
  // нужно ли ее добавлять сюда?
  float goal[4];
};

class Formation {
public:
  enum formation {
    line,
    wedge,
    no_formation
  };

  enum class state {
    broken,
    forming,
    formed
  };
  
  struct CreateInfo {
    formation type;
//     uint32_t rows;
    uint32_t maxRowUnits; // скорее всего эта переменная является определяющей
    uint32_t minRowUnits;
  };
//   Formation(const CreateInfo &info);
  Formation();
  ~Formation();
  
  void changeFormation(const formation &t, const uint32_t &maxRowUnits, const uint32_t &minRowUnits = 1); //const uint32_t &rows, 
  void regroup(const uint32_t &maxRowUnits, const uint32_t &minRowUnits = 1);
  void setUnitsIndent(const float &indent);
  void setRowsIndent(const float &indent);
  void setDirection(const simd::vec4 &dir);
  void computeFormation(const simd::vec4 &goal); 
  // что здесь должно произойти? если формация сломана, то мы должны начать востанавливать ее
  // посчитать центроид, найти ближайший юнит к центру (хотя можно наверное ближайший юнит к точке к которой нужно двигаться)
  // этот юнит будет у нас локальным командиром (наверное нужно все же командиром сделать шефа группы, ну или любого юнита того же типа)
  // вокруг локального лидера будет строиться отряд, нужно посчитать положение слотов, лидера можно наверное отправить вперед, 
  // но так чтобы за ним поспевали все остальные, следовательно если мы пустили лидера вперед, то нужно и точки в слотах пододвинуть
  // по этим точкам вычисляем направления для всех остальных членов отрядов
  // в каком случае у нас формация сломана? когда много челиков стоят относительно далеко от позиций указанных в слотах
  // в каком случае формация формируется? когда челики получили все указания и двигаются в сторону слотов
  // в каком случае формация сформирована? когда челики стоят почти на своих местах
  
  // как сделать движение к пути? по идее там используется одна точка из фуннела, так что проблем быть не должно
  
  formation type() const;
  enum state state() const;
  size_t size() const;
  float unitsIndent() const;
  float rowsIndent() const;
  float maxRowWidth() const;
  uint32_t rowCount() const;
  simd::vec4 direction() const;
  simd::vec4 centroid() const;
  
  std::vector<FormationSlot> & data();
  const std::vector<FormationSlot> & data() const;
private:
  formation t;
  enum state s;
  uint32_t maxRowUnits;
  uint32_t minRowUnits;
  float unitIndent;
  float rowIndent;
  float dir[4];
  std::vector<FormationSlot> slots;
};

// также я как то должен сделать групповую связь энтити
// в групповой связи неплохо было бы сделать возможность совместных действий
class AIGroup {
public:
  // по идее попадая в группу, ентити лишается возможности самостоятельно принимать решения
  // вместо этого решения принимаются уже исходя из группы, как это сделать?
  // важно чтобы поиск пути тоже велся от лица группы, и каждый в группе получал индивидуальные
  // приказы на то куда идти, а также умел верно перестраиваться
  // движение в группе должно учитывать и flocking способ (то есть движение всем скопом)
  
  // может быть в будущем потребуется какие нибудь "виртуальные" группы
  // они будут собираться по сходным данным энтити
  
  // может ли энтити одновременно находится в двух группах? 
  // вряд ли, тогда ставится непонятно приказы какой группы он исполняет
  
  // можно ли здесь избежать проверок? не уверен
  // что с возвращаемым значением? в принципе с поиском пути все однозначно
  // стоп а куда отправлять эвенты? всем энтити? а как потом быть с поиском пути?
  // по идее для поиска пути указывать группу, ну да я так найду путь, а потом что?
  // мне нужно как то из группы заставить работать энтити, в том плане
  // что следующий шаг энтити зависит от шага предводителя группы, либо от группы в целом
  // это вопрос, после шага с поиском пути мы как-нибудь отдельно помечаем этот случай
  // пока я ни в чем не уверен
  
  // скорее всего эвент должен отправляться только групИИ
  // а уже ии группы будет следить за всеми остальными объектами
  event pushEvent(const EntityAI* member, const Type &event, void* data);
  event pushEvent(const Type &event, void* data);
  
  void setTarget(const EntityAI* target);
  
  void addToGroup(const EntityAI* ent);
  
//   const EntityAI* ai() const;
  const EntityAI* member(const size_t &index) const; // тут по идее можно вернуть массив указателей
  const EntityAI* chief() const; // в основном это формальный глава, но мне нужно как то сделать так чтобы он лично мог выполнять какие-нибудь действия
  size_t size() const;
  
  simd::vec4 position() const;
  simd::vec4 direction() const;
  simd::vec4 extents() const;
  
  // у нас должен быть метод который проверит находится ли вся группа внутри блока группы
  // есть некий боундинг бокс группы, если позиции внутри него, то вернем труе
  // для чего нам это нужно? мне нужно определить перемешан ли строй...
  // нет что тут не так, короче, судя по интернету, форматион нужно организовать через специальные слоты
  bool isGroupInBounds() const;
  
  // тут 100% что то еще добавится
  // как посмотреть размеры и ориентацию группы? просто еще несколько данных + обновляем группу
  // ориентацию группы мы по идее можем посмотреть из groupAI
  // размеры нужно указать тут явно
  // это и будет групИИ наверное, не нужно выделять отдельную какую то штуку
private:
  // массив энтити
  // один из энтити должен быть командиром
  // при смерти командира может возникнуть ситуация когда группа распадается
  // как это сделать? то есть как сделать так чтобы это можно было легко модифицировать?
  // на мой взгляд группа должна переставать существовать при определенных условиях
  // которые можно заранее узнать (мало членов, умер последний энтити который может стать командиром)
  
  // группа должна иметь свое дерево поведения (группа действует всегда по своему)
  // у группы должен быть свой энтитиАИ, как сделать так чтобы было удобно?
  // добавить в таргет указатель на группу, и флажок является ли этот энтити группой или он входит в группу?
  // хотя возможно можно будет обойтись и без флажка
  
  // у меня скорее всего не будет особой текучки, но все равно было бы неплохо какой-нибудь статический контейнер заиметь
  // и хранить все указатели на энтити только в этом контейнере
  
  // держать строй видимо челики будут по команде, так как это не всегда уместно, наверное только при передвижении, перегруппировке и еще что то
  // видимо групИИ добавит много новых эвентов (держать строй (то есть встать на свои места если чутка разнесло), перегруппироваться (если разнесло сильно - то поменять слоты))
  // (двигаться строем (то есть направление берется одно, по нему двигаются все члены отряда + корректируют направление тоже все вместе))
  // также должно быть понятие ряд, колонна, скорее всего берутся от направления всего отряда
  
//   glm::vec4 extents;
  // данные группы?
  
  EventComponent* localEvents;
  
  Type lastEvent;
  
//   EntityAI* groupAI;
  const EntityAI* groupChief;
  std::vector<const EntityAI*> members;
  std::unordered_set<Type> tags;
  std::unordered_map<Type, size_t> localBlackboard;
};

#endif
