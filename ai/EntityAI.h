#ifndef ENTITY_AI_H
#define ENTITY_AI_H

#include "EventComponent.h"

#include "Utility.h"

class AIGroup;
class vertex_t;
class edge_t;
class EntityAI;
class StateController;

struct AdditionalAIData {
  float r;
  vertex_t* vertex;
  vertex_t* lastVertex;
  size_t timeThreshold;
  size_t currentTime;
  
  const EntityAI* targetPtr;
  AIGroup* groupPtr;
};

class EntityAI {
public:
  EntityAI();
  ~EntityAI();
  
  // этот класс будет вызывать эвенты
  event pushEvent(const Type &event, void* data);
  
  //event addToGroup(const EntityAI* chief); // по идее это мы делаем эвентом
  
  void setTarget(const EntityAI* target);
  
  // тут еще пригодится локальный блэкбоард
  
  // тут скорее всего еще что-то должно быть для бектрекинга
  // найти энтити по тому что у меня есть я смогу, но смогу ли я сделать другие вещи?
  // опять же мне сейчас быстро ничего в голову не приходит, и на мой взгляд этих данных достаточно
  // для тех задач, которые у меня будут
  
  const EntityAI* target() const;
  bool hasTarget() const;
  
  simd::vec4 position() const;
  simd::vec4 direction() const;
  simd::vec4 velocity() const;
  float raduis() const;
  
  bool hasGroup() const;
  bool isGroupAI() const;
  bool isGroupChief() const;
  const AIGroup* group() const;
  // еще мы наверное должны вернуть какой-то групповой статус
  
  // еще наверное в будущем пригодится ориентация в графе
protected:
  // так ли нам необходимо держать здесь pos, dir, vel?
  // первостепенной необходимости в этом нет, но это поможет обеспечить локальность данных
  // вообще это пригодится еще для группового ии
  
  simd::vec4 pos;
  simd::vec4 dir;
  simd::vec4 vel;
//   float r;
// //   uint32_t vertexId;
// //   uint32_t lastVertexId;
//   vertex_t* vertex;
//   vertex_t* lastVertex;
//   size_t timeThreshold;
//   size_t currentTime;
//   
//   EntityAI* targetPtr;
//   AIGroup* groupPtr;
  
  AdditionalAIData aiData;
  
  EventComponent* localEvents;
  StateController* states;
  
  // тут по идее также поведенческое дерево
  
  //StateController* states; // пригодится чтобы узнать текущее состояние
  //AttributeContainer* attributes; // атрибуты всегда могут потребоваться
  //Vertex* vertex; // вершина (ну точнее то на чем мы сейчас стоим)
  
  // указатель на локальные эвенты
  
  // также у нас должны быть указатели на данные восприятия
  // то есть мы должны взять коллизию, пересечение лучей
  // и еще какие данные
  // в коллизии наверное имеет смысл указать только колизию с ии объектами
  // пересечение лучей для видимости 
};

// слот в группе, использоваться должен для того чтобы отделить одного актора группы от другого
// в том плане, чтобы они не перекрывали друг другу дорогу
// группа должна расчитать положение слотов в конечной точке, и исходя из этого направить энтити
// передвижение будет осуществлятся в соответствии этим слотам, 
// по этим слотам так же нужно вычислить формацию войск
// с формациями сложнее, не знаю как их представить...
// как бы так сделать, чтобы это потом можно было бы размножить на любое количество слотов?
// у любой формации есть несколько одинаковых признаков: количество энтити в одной линии, 
// (количество линий вычисляется на основе этого, да и предыдущий параметр может быть вычислен на основе количества энтити)
// тут скорее правила вычисления линии, тип при свинье у нас первая линия меньше, остальные одинаковы
// при клине у нас первая линия из одного, остальные +1 больше
// нашел текст, который предлагает ввести виртуального лидера для поддержки формации
// а формацию придется видимо сделать с помощью интерфейсов
struct GroupSlot {
  EntityAI* entity;
  uint32_t index;
  
};

// также я как то должен сделать групповую связь энтити
// в групповой связи неплохо было бы сделать возможность совместных действий
class AIGroup {
public:
  // по идее попадая в группу, ентити лишается возможности самостоятельно принимать решения
  // вместо этого решения принимаются уже исходя из группы, как это сделать?
  // важно чтобы поиск пути тоже велся от лица группы, и каждый в группе получал индивидуальные
  // приказы на то куда идти, а также умел верно перестраиваться
  // движение в группе должно учитывать и flocking способ (то есть движение всем скопом)
  
  // может быть в будущем потребуется какие нибудь "виртуальные" группы
  // они будут собираться по сходным данным энтити
  
  // может ли энтити одновременно находится в двух группах? 
  // вряд ли, тогда ставится непонятно приказы какой группы он исполняет
  
  // можно ли здесь избежать проверок? не уверен
  // что с возвращаемым значением? в принципе с поиском пути все однозначно
  // стоп а куда отправлять эвенты? всем энтити? а как потом быть с поиском пути?
  // по идее для поиска пути указывать группу, ну да я так найду путь, а потом что?
  // мне нужно как то из группы заставить работать энтити, в том плане
  // что следующий шаг энтити зависит от шага предводителя группы, либо от группы в целом
  // это вопрос, после шага с поиском пути мы как-нибудь отдельно помечаем этот случай
  // пока я ни в чем не уверен
  event pushEvent(const EntityAI* member, const Type &event, void* data);
  
  const EntityAI* ai() const;
  const EntityAI* member(const size_t &index) const; // тут по идее можно вернуть массив указателей
  const EntityAI* chief() const; // в основном это формальный глава, но мне нужно как то сделать так чтобы он лично мог выполнять какие-нибудь действия
  size_t size() const;
  
  simd::vec4 position() const;
  simd::vec4 direction() const;
  simd::vec4 extents() const;
  
  // у нас должен быть метод который проверит находится ли вся группа внутри блока группы
  // есть некий боундинг бокс группы, если позиции внутри него, то вернем труе
  // для чего нам это нужно? мне нужно определить перемешан ли строй...
  // нет что тут не так, короче, судя по интернету, форматион нужно организовать через специальные слоты
  bool isGroupInBounds() const;
  
  // тут 100% что то еще добавится
  // как посмотреть размеры и ориентацию группы? просто еще несколько данных + обновляем группу
  // ориентацию группы мы по идее можем посмотреть из groupAI
  // размеры нужно указать тут явно
private:
  // массив энтити
  // один из энтити должен быть командиром
  // при смерти командира может возникнуть ситуация когда группа распадается
  // как это сделать? то есть как сделать так чтобы это можно было легко модифицировать?
  // на мой взгляд группа должна переставать существовать при определенных условиях
  // которые можно заранее узнать (мало членов, умер последний энтити который может стать командиром)
  
  // группа должна иметь свое дерево поведения (группа действует всегда по своему)
  // у группы должен быть свой энтитиАИ, как сделать так чтобы было удобно?
  // добавить в таргет указатель на группу, и флажок является ли этот энтити группой или он входит в группу?
  // хотя возможно можно будет обойтись и без флажка
  
  // у меня скорее всего не будет особой текучки, но все равно было бы неплохо какой-нибудь статический контейнер заиметь
  // и хранить все указатели на энтити только в этом контейнере
  
//   glm::vec4 extents;
  
  EntityAI* groupAI;
  EntityAI* groupChief;
  std::vector<EntityAI*> members;
};

#endif
