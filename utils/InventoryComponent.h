#ifndef INVENTORY_COMPONENT_H
#define INVENTORY_COMPONENT_H

#include <cstdint>
#include <cstddef>
#include <vector>

#include "Type.h"
#include "Attributes.h"
#include "MemoryPool.h"
#include "Interaction.h"

#include "EventFunctor.h"

// что такое инвентарь? набор энтити сгруппированных по похожести, причем подобрать я могу не только один предмет
// значит 100% должно быть некое сравнение энтити между собой
// должно быть хранилище этих энтити, отрисовка этого хранилища для игрока

// при попадании в инвентарь я могу избавиться вообще от всех остальных компонентов,
// в случае выкидывания удалить этот энтити создать новый такой же, только уже со всеми нужными компонентами
// мало того, мне достаточно одного последнего энтити или даже вообще ничего не надо
// в этом случае как тогда сохранить характеристики для того чтобы их сравнить потом?
// я так понимаю, я могу оставить только первый предмет такого типа в инветаре, все остальные энтити удалить
// что то еще можно придумать? нет все же наверное должен быть лист из энтити
// в айтем положим указатель на следующий, в каунт - сколько айтемов осталось в списке
// конкретно этот подход разбивается об необходимость каким-то образом управлять энтитями при выбрасывании
// (мы можем выбрасывать произвольное количество объектов, вне зависимости от стака, который мы подобрали)
// создавать отдельный энтити для каждого объекта? (тогда вся память выжрется стрелами)
// наиболее подходящий способ все же при добавлении в инвентарь удалять мировое представление
// и видимо заместо него создавать представление в инвентаре, как быть с одеванием?
// по идее это просто другой статус у предмета и нам нужно создать еще одно представление
// но в этом случае нужно загрузить еще модельку или картинку

// посмотрев код openmw я увидел, что практически все сущности там строго опрелены
// то есть сущность книга, сущность оружее и прочее, а в инвентаре лежит конкретная сущность
// в инвентаре есть возможность сложить сущности в один стак, взять из инвентаря стаком
// пересобрать стаки и прочее

// короче, я склоняюсь к такому же варианту (но наверное нужно разделить предметы и патроны в конкретной игре)
// я пока еще не понял как там объекты можно было выложить стаком, но думаю пока не нужно об этом думать

// я примерно понял как можно сделать фактори для энтити
// нужен специальный энтити составленный из специальных компонентов
// при объходе которых, например с помощью fireEvent будет собираться новый энтити
// в этом случае нужно решить вопрос со строгой последовательностью
// + с передачей данных о энтити, хотя может эта идея и не очень

// честно я все больше склоняюсь к тому что необходимо отделить оружие от итема
// в пользу этого говорит то что итем используется независимо ни от чего
// я вполне могу его использовать во время атаки
// с другой стороны в оружии добавится не очень много уникальных данных

// главная причина моего такого долгого зависания на этой теме в том,
// что я пытаюсь приладить все это дело к системе эвентов, и это у меня в упор не хочет прилаживаться
// видимо неочень хорошее было решение с эвентами, проблема заключается в том что мне нужно часто общаться между компонентами
// энтити, а эвенты не могут гарантировать мне порядок этого общения, а так же адекватную проверку условий
// иное решение заключается в том чтобы продумать интерфейсы ко всем возможным формам взаимодействий
// то есть интерфейсы: скиллы, атака (или атака должна быть в скиллах?), итемы, движение,
// эти интерфейсы видимо будут менять состояния объекта
// атака сама по себе может быть и в скиллах, но вот оружее должно быть где-то около предметов
// что нам это дает? во впервых никаких эвент компонентов, во вторых ии использует только определенные интерфейсы
// новые интерфейсы добавить будет сложнее, нужны ли они мне? я так не думаю
// что теперь? интерфейс скиллов, и предметов нужен
// такие базовые вещи как звук, анимация в ue4 делаются где то уровнем ниже
// все равно не очень понимаю как связать одно с другим
// в ue4 анимация сообщает о том когда нужно запусить какой то эффект (звук, частицы)
// ну и стейт соответственно привязан к анимации, вообще у меня примерно та же история
// то есть при определенных анимациях нужно запускать звук
// короче, в состоянии будет только анимация, звук, состояние мы меняем в разных местах (скиллы, движение)
// в скиллах должно быть начальное состояние с характеристиками
// видимо в данный момент у меня будет 3 интерфейса: скиллы, инвентарь, движение
// что с эвентами? видимо ничего, не нужны
// что в будущем с таким подходом меня ожидает? в будущем 2 важных преобразования намечается:
// скелетная анимация ... и большая часть взаимодействий будут коллизией (важно ли?)
// первое усложняет работу с состояниями, второе кажется ничего особенного не представляет из себя
// у скелетной анимации появляется необходимость плавного перехода между состояниями + несколько состояний параллельно
// впрочем скорее всего интерфейсы над этим не изменятся

// единственное что давали мне эвенты - это способ как организовать реакцию на атаку у стен и декора
// еще эвентами можно было ограничить функции от исполнения в разных потоках
// в этом случае видимо придется делать компонент синхронизации (структура с мьютексом? видимо да)
// смерть? ну видимо еще один компонент должен все это дело брать на себя

// интерфейсы? skills, inventory, motion ... ? эффекты - ридонли

//class InventoryInterface {
//public:
//  virtual ~InventoryInterface() = default;
//
//  // смена оружия, использование предметов
//  // врядли будет сильно отличаться от компонента
//  // думаю что лучше именно с компонентом работать
//};

namespace yacs{
  class entity;
}

class AttributesComponent;
class EffectComponent;
class InteractionComponent;
class Effect;
class StateControllerType;

struct WeaponItemData {
  // я хочу сделать еще магические атаки
  // эти атаки появляются из-за того что игрок нажал на определенный скилл
  // короче еще должна быть тема со скиллами
  // что мне нужно для простого оружия? патроны - может быть даже двух типов
  // для этого явно не нужен вектор
  //std::vector<AttributeType<INT_ATTRIBUTE_TYPE>> ammoTypes;
  TypelessAttributeType ammoType;

  const Effect* weaponEffect; // эффект накладывается при атаке
  const StateControllerType* player;
  const StateControllerType* other;
};

struct InteractionData {
  float angle;
  float plane[4];
  uint32_t tickCount;

};

// наложение эффекта по идее может менять не только характеристики, а также добавлять дополнительные эффекты к урону

class ItemType {
public:
  struct CreateInfo {
    Type id;
    Type itemGroup;

    std::string name;
    std::string description;

    const Effect* itemEffect;

    Type itemEvent;
    enum Interaction::type itemType;
    InteractionData interactionData;
    WeaponItemData weaponData;
//    std::vector<TypelessAttributeType> compareTypes;

//    std::function<event(const std::vector<AttributeType<INT_ATTRIBUTE_TYPE>>&, AttributesComponent*, InteractionComponent*)> func;
  };
  ItemType(const CreateInfo &info);
  ~ItemType() = default;

  Type id() const;
  Type group() const;

  std::string name() const;
  std::string description() const;

//  const std::vector<TypelessAttributeType> & compareAttributeTypes() const;

  // придется наверное вытащить интеракцию отсюда
//  event interaction(AttributesComponent* attribs, InteractionComponent* inter) const;

  // может потребоваться отменить интеракцию, когда отменить? у кого отменить?
  // если у игрока то врядли, монстр не использует это
//  void cancel_interaction(InteractionComponent* inter) const;

  const StateControllerType* playerStates() const;
  const StateControllerType* objectStates() const;

  bool isWeapon() const;

  const Effect* itemEffect() const;

  Type useEvent() const;
  enum Interaction::type useType() const;

  // тогда нужно еще задать какие то базовые данные
  const InteractionData & itemInteractionData() const;
  const WeaponItemData & weaponItemData() const;

  // мы из оружия должны как то получить эффект
  // да вообще в принципе айтем нам должен давать эффект
private:
  Type typeId;
  Type itemGroup; // лучше наверное группу сделать через int, ну то есть как collisionGroup
  // до этого нужно доделать CompositeType
  // хотя смысл в группе через инт? неизвестно как делать сортировку

  // где то рядом нужно всеже ввести количество объектов
  // думаю что это нужно сделать через аттрибут,
  // придется тогда серьезный код написать для того чтобы
  // правильно удалять объекты, если мы берем стаком,
  // правильно создавать объекты, если мы пытаемся стаки разделить

  // когда берем в руки оружее применяем этот эффект к игроку
  // эффект должен настраивать челика перед атакой, что это значит?
  // дальность атаки, скорость атаки,

  // впринципе эффект я могу использовать для практически всех взаимодействий с предметами
  // как сделать модификатор к оружию? чтоб можно было включать/выключать некоторые типы атаки
  // у меня есть эвент атака, и я раньше планировал на него подписываться
  // у меня должен быть скилл который тоже подпишется на этот эвент

  // эффект который мы передаем при атаке? вынести интеракцию всеже из функции?
  // мы берем в руки оружие и должны во первых именить некоторые характеристики энтити
  // во вторых передавать другой эффект урона

  // должен быть также эффект при атаке

  // анимации? как уже было сказано состояния, в чем здесь проблема?
  // проблема в том что у каждого итема разные анимации

  std::string typeName;
  std::string typeDescription;

  const Effect* effect;

  // это не только у оружия может быть
  // я решил отказаться от эвентов, а это значит что? мне нужна глобальная функция взаимодействия?
  // по идее функция одна: два энтити, тип взаимодействия остается - это минимальный набор того что нужно
  // при использовании предмета применяем заданный эффект, также эффект от предмета может давать возможность
  // накладывать эффекты на других
  Type attackEvent;
  enum Interaction::type attackType;
  InteractionData interactionData;

  WeaponItemData weaponData;

  // типы к сравнению, возможно не потребуется, наверное даже потом изменится
  //std::vector<TypelessAttributeType> compareTypes;

  // если патроны у нас хранятся в аттрибутах, то мы можем использовать эффект
  // но эффект будет только вычитать, но мне нужно посмотреть еще и состояние
  // и если патронов не хватает, то как пресечь изменение состояния?
  // следовательно у состояний должно быть условие его изменения

  // нужны еще данные для интеракции, эти данные скорее всего могут задаваться как константы
  // сразу при создании той или иной интеракции, нужны ли мне эти данные?
  // кроме attackTime, delayTime и, наверное, tickCount остальное я не знаю где может пригодится
  // у нас еще могут быть данные для других интеракций, нужно бы задавать какие-нибудь константы
  // в json чтобы ошибки сокращать, в общем то константы из json'а очень неплохо смотрятся
//  float thickness;
//  float attackAngle;
//  float plane[4];

//  uint32_t tickCount;
//  uint32_t ticklessObjectsType;

//  size_t delayTime;
//  size_t attackTime;
//  size_t tickTime;

  // возможно даже не std::function, а указатель на виртуальную функцию
//  std::function<event(const std::vector<AttributeType<INT_ATTRIBUTE_TYPE>>&, AttributesComponent*, InteractionComponent*)> func;
  // здесь же можно сделать и уменьшение аттрибутов (использование патронов например)
  // тогда нужно сделать AttributesComponent не константным

  // потом по всей видимости будет атаковать не игрок, а оружее (то есть аттрибуты будем смотреть у оружия)

  // еще одна полезная фича - это передать какому нибудь объекту импульс, external data
  // вообще конечно необходимо сделать специальную комнату для специальных эффектов,
  // где будет доступно максимум компонентов, и будет возможность описать практически любое
  // взаимодействие, в принципе это можно сделать в рамках UserInputComponent

  // здесь я могу хранить эффекты которые мне нужно применить при разных обстоятельствах
  // пока что предмет можно только использовать, но с другой стороны при использовании эффекта
  // мы можем например открывать некоторые двери, то есть итем должен интеракцию создавать
  // в том числе может и оружее так делать! интеракция у итема? ну да мне же нужно будет
  // еще сделать какой нибудь проджектайл (тип у бомб каких нибудь), как их сделать?
  // лучше бы конечно использовать виртуальную функцию - так будет быстрее
  //

  // тут то и можно хранить иконку для объекта в инвентаре
  // а потом и модельку какую
  // звуковой эффект при использовании?

  // вся эта тягомотина с интеракциями выглядит как костыль
  // в опенмв, как я понял, у каждого оружия есть 3 вида атаки
  // (ну и + лук и метательное), оружее просто выставляет
  // необходимые характеристики, по которым выбирается наилучшая
  // атака, у меня же вопрос встает с анимацией, как ее сделать?
  // в типе итема указать анимации? вообще возможно это неплохая идея

  // еще одна проблема как узнать что у нас сейчас есть какое то действие
  // например сейчас проходит какая то атака
  // блокирующие/неблокирующие анимации? может ли у нас быть блокирующая не анимация?
  // звук? интеракция по хорошему как раз должна быть блокирующей
  // интеракцию то мы должны как то завершать, а вместе с ней и возможный звук и анимацию
  // короч до сих пор не очень понимаю как это реализовать
  // короч, почитал, предлагают использовать анимации, как раздатчик эвентов
  // то есть определить точки анимации при которых нужно вызывать эвенты на разные действия
  // логично, с самого начала я хотел сделать чтото подобное
  // походу нужно переработать концепцию StateController'а
  // в принципе, это будет работать примерно так:
  // приходит эвент, я нахожу состояние для этого эвента, предыдущее состояние прерываю,
  // ставлю новое, у каждого состояния есть пачка свойств, из стейт контроллера можно взять нужное свойство
  // у состояния скорее всего должен быть какой-нибудь переход в следующее
  // так, теперь я сделал контроллер состояний
  // осталось понять как отменять атаку, понятно что я должен передать в интеракцию
  // тип и эвент связанный

  // так короче для решения проблем с синхронизацией анимаций и действий нужна иерархия
  // где некая сущность (скорее всего ДЕЙСТВИЕ) будет использовать компоненты
  // при изменении своего состояния, возможно стоит выделить отдельный компонент
  // с действием, то есть примерно как стейтконтроллер, но с явно выраженой передачей ресурсов
  // вниз по иерархии (то есть стейт получает собственно стейт, по типу выясняет что необходимо сейчас сделать)
  // (передает РесурсИд анимации, звукам, тд, создает новую интеракцию, и прочее)
  // нет, кажется достаточно StateControllerType
};

class Item {
public:
  struct CreateInfo {
    size_t quantity;
    const ItemType* type;
  };
  Item(const CreateInfo &info);

  size_t quantity() const;
  const ItemType* type() const;
protected:
//  UserDataComponent* entityData;

  // скорее всего нужно будет еще сравнить какие нибудь характеристики, например, для зелий силу и время действия
  // но это при условии что есть возможность создать одинаковые зелья с разными характеристиками
  // мне еще хранить массив характеристик для сравнения чтоли? должен быть ItemType какой нибудь
//  AttributesComponent* attribs;

//  EffectComponent* effects; // зачем это здесь?

  // что происходит при использовании? может быть мы просто должны передать эффект?
  // эффект - это штука мощная, позволяет легко обновить аттрибуты у игрока
  // причем мне не придется создавать какую-то особую функцию (или тащить за собой EventComponent)
  // с другой стороны EffectComponent тоже достаточно тяжелый

  size_t m_quantity;
  const ItemType* m_type;
};

// специальный тип итема, у нас должно быть текущее оружее
// оружее должно каким то образом задать характеристики,
// которые затем используются при атаке
// у оружия есть патроны, которые наверное в текущем виде будут просто аттрибутом
// этот класс нам должен сказать какой тип взаимодействия делать, то есть
// должен вернуть тип взаимодействия (может быть несколько)
// характеристики атаки? по идее когда мы оружее взяли в руки, необходимо изменить некоторые аттрибуты
// и по измененным характеристикам сгенерировать интеракцию

// в своих размышлениях я пытался повторить инвентарь морровинда
// но мне на самом деле делать это совершенно не обязательно
// и вообще то говоря мне нужен только тип итема
// а, я пытался в основном повторить различия у свойств предмета
// этот случай скорее всего я рассматривать не буду
// но в будущем как это можно было бы сделать? сильно переусложнять не хочется
// аттрибуты у итема? ну это скорее всего самый адекватный подход
// но при этом это приведет к тому что каждая, например, стрела будет уникальной
// что означает неимоверный расход памяти на это дело
// с другой стороны нужно тогда разделить конкретный итем и его представление в мире
// и например, уникальные свойства итема - уникальный тип с другим эффектом
// несколько характеристик которые необходимо вынести в конкретный итем
// ("здоровье" предмета и все?), при выкидывании предмета по представлении в инвентаре
// и типу создавать энтити

// этот класс может пригодиться как наследник итема, и должен давать новые анимации и звуки
//
//class Weapon : public Item {
//public:
//
//private:
//  AttributesComponent* attribs;
  // сколько патронов указать? может и быть оружее которое берет больше чем один тип патронов? по аналогии с hexen'ом может
  // тип патронов заранее известен, мы можем собирать патроны при атаке
  // изменять характеристики проще всего с помощью добавления/удаления эффекта

  // тип оружия? будет, в типе необходимо указать какую интеракцию создавать
  // и сколько патронов забрать, как передать характеристики проджектайлу?
  // у определенного проджектайла всегда определенный набор характеристик,
  // эти же характеристики мы можем расположить у энтити и при создании передать одно другому
//  WeaponType* type;

  // оружие должно передавать новую анимацию в зависимости от состояния
  // состояния, а точно ли должны быть состояния в оружие? это правда что оружие так
  // или иначе меняет анимации у игрока/монстра, но должно ли оружее контролировать
  // состояния? вряд ли, то есть оружие только должно хранить состояния
  // вообще похоже что это проблема исключительно 2d отображения объектов
  // так как в 3d нам нужно то только передать модельку + матрицу положения
  // как быть? скорее всего лучше ничего особенного не добавлять в оружее
  // а контролировать все эти вещи в другом месте, у игрока более менее
  // понятно где контролироваться это будет (некий аниматион сиквенс, который пока не написан)
  // что с монстром? у него может быть несколько оружий, несколько типов атак
  // я думаю о том что нужно добавить еще интеракций по типу
  // просто передать в итем тип дополнительно к тому что уже есть
  // это поди сильно перегрузит ИтемТайп, лучше все же разделить
  // и действительно разное оружее с разным типом использовать
//};

struct ItemStack {
//  std::vector<Item*> items;
  const ItemType* type;
  size_t count;
  // для нескольких предметов нам может пригодится состояния и здесь
};

//struct WeaponData {
//  Type event;
//  const ItemType* weapon;
//
//  // способ по которому мы должны узнать есть ли у нас это оружее
//  // можно просто проверять nullptr, как тогда точно гарантировать тип оружия?
//  // гарантировать тип оружия здесь? идея скорее не очень
//  // я планирую сделать несколько персонажей, у них будет разное оружее
//  // понятное дело нужно брать всегда оружие персонажа, должен ли здесь код поменяться?
//  // проверки можно организовать в другом месте при взятии например
//  // большая часть вещей будет независима от персонажа (точнее все предметы независимы, а оружее будет зависимо)
//};

class InventoryComponent {
public:
  struct CreateInfo {
    std::vector<ItemStack> predefinedItems;
//    size_t maxWeaponsCount;
//    std::vector<WeaponData> predefinedWeapons;
    size_t weaponCount;
    std::vector<const ItemType*> predefinedWeapons;
  };
  InventoryComponent(const CreateInfo &info);
  ~InventoryComponent();

  size_t add(const ItemType* item, const size_t &count = 1); // возвращает сколько айтемов этого типа после добавления
  size_t remove(const ItemType* item, const size_t &count = 1); // возвращает сколько удалось удалить
  size_t nextItem();

  size_t count(const ItemType* type) const;
  size_t index(const ItemType* type) const; // SIZE_MAX - такого типа нету в инвентаре

  const ItemType* currentItem() const;

  size_t itemCount() const;

  // мне наверное нужно гарантировать что оружие будет только в определенных ячейках
//  void addWeapon(const ItemType* weapon, const Type &event, const size_t &index);
  void addWeapon(const ItemType* weapon, const size_t &index);
  void removeWeapon(const ItemType* weapon); // может ли когда нибудь произойти?
  const ItemType* nextWeapon(); // меняем оружее на следующее

//  const ItemType* weapon(const Type &event) const;
  const ItemType* weapon(const size_t &index) const;

  bool hasWeapon(const ItemType* weapon) const;
  bool hasWeapon(const Type &type) const;

  const ItemType* currentWeapon() const;

  size_t weaponCount() const;

  // условие? по идее сортировать мы должны по итем группе
  void sort();
private:
  size_t currentItemIndex;
  std::vector<ItemStack> items;
  //MemoryPool<ItemStack, sizeof(ItemStack)*10> stackPool;
  // мемори пул? видимо придется добавить для того чтобы сортировка не была такой унылой

  // при смерти противник может дропнуть итем

  // должно быть разделение между итемами и оружеем
  // нужно ли делать монстрам больше одного оружия?
  // ну атак у них вполне может быть много разных, например, ближняя и дальняя
  // у игрока должно быть оружее по умолчанию
  // как запускать анимацию и звук при использовании оружия?
  // текущее оружее должно что то менять?

  // находим оружее по эвенту
//  size_t currentWeapon;
//  std::vector<WeaponData> weapons;

  // проверку можно сделать и здесь, массив Type
  const size_t weaponCountVar;
  size_t currentWeaponIndex;
  const ItemType** weapons;

  const ItemType* temporaryWeapon;

  size_t findIndex(const size_t &start, const ItemType* type) const;
};

class UserInventoryComponent {
public:

private:

};

#endif //INVENTORY_COMPONENT_H
