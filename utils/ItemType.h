#ifndef ITEM_TYPE_H
#define ITEM_TYPE_H

// абилка при взятии оружия в руки, абилка при нажатии кнопки мыши
// эффекты? могут пойти от взятия, нужно их только удалить после того 
// как мы сменим оружее, обойти и удалить эффекты абилки? почему нет
// как определить оружее ли это или абилка? у оружия задана абилка при атаке
// как задать разный стейт для последовательных атак? указать несколько 
// абилок и стейтов при атаке и последовательно их менять друг за другом
// как указать что мы именно меняем оружее? нужно некое булево значение
// как проверить какой стейт из последовательных текущий? 
// сделать проверку с текущим стейтом энтити, то есть тут скорее 
// использование абилки при правильном стейте, если типы стейтов совпадают, 
// то используем заданую абилку, как быть с переходами?
// меч наизготовке на правой стороне -> атака в этом случае это переход в стейт
// атаки справа + использование абилки -> готовимся к атаке слева -> стейт атаки слева + абилка
// если атаки слева нет, то переходим в стейт готовности атаковать справа, как учесть этот переход?
// указывать старт абилки, следующий стейт и саму абилку? это позволит решить эту проблему конечно
// есть ли иной способ? абилка задает стейт логично что в зависимости от абилки идет анимация и звук
// а не наоборот, + указать стартовый стейт (стейт каста абилки?)
// огненный шар например должен требовать каста прежде чем в руки попадает собственно шар
// абилки начальной нет, есть стейт взятия (не дает ничего использовать пока не закончится каст)
// затем получаем в руках оружие, нажимаем на кнопку - кидаем огненный шар, 
// при касте, но не при использовании должна сниматься мана, значит есть абилка очень простая
// то есть у нас будет абилка+стейт, стейт из абилки по приоритету, при использовании оружия 
// с помощью указаного стейта будем проверять какую абилку сейчас использовать
// как определить что это айтем? есть абилка взятия, но нет атак абилок
// как оличить айтем от абилки? в общем то никак, нужно как то иначе разделить эти два понятия

// время каста можно теперь не указывать в абилке

// я очень не хотел разделять айтем и оружее
// но мне нужно как то передать переменные в создание интеракции
// все упирается в то как я это буду делать

// не, разделять айтем и оружее не обязательно
// нужно указать данные для интеракции в виде переменная: число|тип аттрибута
// в этом случае нам нужно будет указать два энтити для размашистых атак война

#include "Type.h"

#include <vector>

class Effect;
class AbilityType;

class ItemType {
public:
  struct AbilitySlot {
    size_t slotIndex;
    const AbilityType* ability;
    Type state;
  };
  
  struct Ability {
    const AbilityType* ability;
    Type state;
  };
  
  struct CreateInfo {
    Type m_id;
    Type m_group;
    std::string m_name;
    std::string m_description;
    
    bool isItem;
    Ability useAbility;
    std::vector<Ability> attackAbilities;
  };
  ItemType(const CreateInfo &info);
  
  Type id() const;
  Type group() const; // может быть тут нужен индекс, наверное будет лучше индексом (потом изменю)
  const AbilityType* ability() const;
  std::string name() const;
  std::string description() const;
//   const std::vector<const Effect*> & onPickup() const;
//   const std::vector<const Effect*> & onTakingWapon() const;
//   const std::vector<AbilitySlot> & weaponAbilities() const;
  
  // если это оружее, у него должно быть дефолтное состояние
  
  Ability whenUse() const;
  const std::vector<Ability> & whenAttack() const;
  
  bool isItem() const; // вообще если правильно все раскидать, то нам это может даже не потребоваться
private:
  bool item;
  Type m_id;
  Type m_group;
  std::string m_name;
  std::string m_description;
  
  Ability useAbility; // тут у нас лежит либо дефолтное состояние, либо используемая абилка
  std::vector<Ability> attackAbilities; // отсюда мы берем абилку для атаки, состояние определяет где мы должны находится
  
//   const AbilityType* m_ability;
//   std::vector<const Effect*> pickupEffects;
//   std::vector<const Effect*> weaponEffects;
//   std::vector<AbilitySlot> weaponAbilitySlots;
};

#endif
