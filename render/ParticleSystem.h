#ifndef PARTICLE_SYSTEM_H
#define PARTICLE_SYSTEM_H

#include "Engine.h"
#include "Utility.h"

#include "ArrayInterface.h"
#include "GPUArray.h"
#include "GPUBuffer.h"

#include "Emitter.h"
#include "Frustum.h"

#include <atomic>
#include <mutex>

// у системы частиц должно быть два типа частиц
// во первых просто частицы (вылетающие искры)
// объекты характеризующиеся малым набором данных (позиция, скорость, цвет)
// они будут просто существовать какое то время а потом исчезать
// неплохо было бы чтобы эти частицы хотя бы реагировали на такие вещи как стены
// с помощью например гБуфера, как это сделать? для того чтобы они реагировали
// на гБуфер нужно их отрисовывать после его формирования, тогда они не будут
// адекватно реагировать на свет, ...
// в юнити для частиц реагирующих с объектами сцены предусмотрено вычисление физики
// например проджект тайлы - это и есть партикли как я понял
// у меня тут конечно получается парадокс, прежде всего в том что 
// для того чтобы отрисовать партикл мне нужен гБуфер, который будет заполняться как раз и при отрисовки партикла
// так вот решение
// я рисую геометрию по классике (только геометрию)
// затем запускаю компут шейдер, где вычисляю поз партиклов, перевожу их в клип спейс и чекаю коллизию, чуть чуть изменяю положение
// рендерю все остальное (в том числе и вычисленные партикли)
// в чем беда? партикли могут быть очень быстрыми, из-за чего неверно может вычислиться их отскок от поерхности
// впрочем это скорее всего единственная явная проблема, которая решается просто дизайном

// легкие партикли, нужно ли к ним какую нибудь текстуру? ускорение?
// нужно еще как то явно указать воздействует ли гравитация?
// нужно ли явно указывать гравитацию? можно указать коэффициент воздействия гравитации, [-1;1] например
struct Particle {
  glm::vec4 cur;
//   glm::vec4 pos;
  glm::vec4 vel;
  glm::vec4 col;
  uint32_t currentTime; // можно же вычитать, но тогда я не смогу понять сколько времени прошло (в смысле отношение не смогу взять)
  uint32_t lifeTime;
  uint32_t type;
  uint32_t dummy2;
  float maxScale; // условный размер частицы, пока еще не знаю что это
  float minScale; // скейл у нас может лерпаться от макса к мину от времени
  float minSpeed; // скорость после которой частица останавливается
  float bounce;
  glm::uvec4 texture;
};
// частицы конечно должны быть разными, но при этом одинаковыми для того чтобы их было легче посчитать на гпу
// разность будем тогда контролировать с помощью типа, что нам может потребоваться для частиц?
// скорость, позиция, время, размер, отскок, радиус, цвет, текстура? (пригодится вообще), 
// в типе будем записывать действует ли гравитация, нужно ли лерпать размер, удалять ли частицу сразу при достижении минимальной скорости,
// что еще?

// для того чтобы частицы не попадали внутрь здания в котором находится игрок 
// можно сделать несколько вещей: 1. нарисовать карту глубины для частиц (эт, конечно, идеальный случай и не очень правдоподобный)
// 2. выдать частицам простой коллайдер, с которым они быстро смогут провериться на попадание в определенную область
// для частицы думаю будет достаточно нескольких нормалей выпуклого объекта + (возможно) точки
// нужно еще посчитать правдоподобный радиус для коллайдера, нам такой коллайдер нужен только тогда когда мы находимся внутри здания
// это уже более адекватный вариант

// как частицы удалять? проще всего их не удалять в обчном смысле, а держать огромный буфер, со всеми одинаковыми частицами
// в этом буфере помечать неактивные частицы, считать количество активных и по последнему числу отрисовывать
// для того чтобы все правильно сделать, нам необходимо в этом случае отсортировать частицы
// частиц может быть очень много, может ли сортировка стать проблемой? сортировка на гпу скорее всего врядли станет проблемой
// для 30к частиц, точнее будет явно быстрее чем на процессоре, 30к частиц - ультимативный случай
// в качестве оптимизации нам нужно ввести ограничивающие объемы у эмитеров, по ним мы отсекам целый эмитер и все его частицы
// тут может возникнуть проблема, как посчитать верно частицы у таких эмитеров? в том плане, что у такого эмитера должно состояние двигаться вперед
// например, взрыв, мы его не видим, то смысл его считать пропадает, но вот мы начинаем на него смотреть, а он у нас будет словно с самого начала
// что тут можно придумать? поз - это у нас начальная позиция, а конечную мы получаем перевычисляя заного скорость по времени?
// идея неплоха, но в этом случае у нас может вычислиться неверно физика, хотя может и нет, физика зависит от нормалей и глубины в гБуфере
// может лишь быть что определенная цастица ускакала сильно далеко
// вот еще одна проблема, у нас частицы могут быть ЗА объектом, но при простом подходе могут оказаться ПЕРЕД объектом
// частицы за объектом нужно верно отсекать, мало того, они попрежнему должны взаимодействовать с окружением
// должен быть определенный радиус у частиц, по которому мы и должны се это дело смотреть
// для проверки частиц у нас еще есть предыдущее положение

// тяжелые партикли, объекты с определенным временем жизни, которые создаются как энтити
// в принципе время жизни может быть и бесконечным
// эти объекты будут в общем представлять из себя примерно тоже самое что и монстры
// но в гораздо более облегченной версии, то есть физика + графика + трансформ
// неплохо было бы еще чтоб анимация у них какая нибудь была
// но это скорее всего капец, в том плане, что сейчас для анимации мне необходим еще эвент компонент
// хотя нужно просто константную анимацию какуюнибудь запилить
// то есть только одна анимация и все

// что делать с прозрачными партиклями? (точнее с полупрозрачными) 
// их нужно рисовать в самый последний момент, правильно их освещать я скорее всего не смогу
// с полупрозрачностью у меня проблемы вообще везде, проще от нее вообще отказаться
// но блин я хочу чтобы картинка у меня выглядела побогаче, мне бы еще с фогом разобраться

// партикли мы пихаем в один буфер, чтобы потом посчитать необходимое в компут шейдере
// частицы должны быть единообразными
// затем мы по вычисленной позиции их рисуем, 

// источник частиц, что здесь? вообще мы можем использовать эмиттер чтобы проверить видимость определенных частиц
// это полезно для оптимизации
// + нам нужны разные свойства у частиц, разные места источника и некоторые другие вещи
// думаю что эмиттер полезно сделать компонентом

// с приходом частиц можно сделать систему материалов
// то есть реакция на атаку у разных поверхностей с одним материалом будет одинаковая
// причем как частицы, так и звук
// еще и световые свойства поверхности 
// что для этого нужно сделать?
// материал - это скорее всего просто энтити, с особыми компонентами
// компонент материал, звук, частицы, свойства поверхности
// с тем же успехом могут быть физические свойства поверхности

struct ParticlesCount {
  uint32_t count;  // vertexCount
  uint32_t dummy1; // instanceCount
  uint32_t dummy2; // firstVertex
  uint32_t dummy3; // firstInstance
  // тут по традицции скоре всего пригодится еще и powerOfTwo
  uint32_t powerOfTwo;
};

// максимальный юниформ - 65536 байт кажется
struct ParticlesUniform {
  glm::vec4 gravity;
  //Frustum frustum;
  glm::vec4 planes[6];
  
  uint32_t time;
  uint32_t dummy1;
  uint32_t dummy2;
  uint32_t dummy3;
  
  // здесь же должна быть геометрия для проверки частиц, или несколько
  // для того чтобы частицы не падали не в положенном месте
  // над этим еще нужно будет поразмыслить
};

class ParticleSystem : public Engine {
public:
  ParticleSystem(yavf::Device* device);
  ~ParticleSystem();
  
  void update(const uint64_t &time) override;
  
  void updateFrustrum(const Frustum &frustum); // гравитацию тоже нужно обновить
  
  void add(SmallEmitter* emitter); // скорее всего не пригодится
  
  void addParticle(const Particle &particle);
  
  // после рендера нужно обновить count
  // как это сделать?
  void postRenderUpdate();
  
  size_t count() const;
  
  yavf::Buffer* particlesBuffer() const;
  yavf::Buffer* countBuffer();
  yavf::Buffer* uniformBuffer();
private:
  yavf::Device* device;
  
  std::vector<SmallEmitter*> emitters;
  
  size_t countVar;
//   std::atomic<size_t> count;
  std::mutex mutex;
  GPUArray<Particle> particles; // это у нас живые частицы, они по идее должны генерится с помощью эмитера
  GPUBuffer<ParticlesCount> gpuCount;
  GPUBuffer<ParticlesUniform> uniform;
};

#endif
