#ifndef EMITTER_H
#define EMITTER_H

#include <cstddef>

class ParticleSystem;

class Emitter {
public:
//   Emitter(ParticleSystem* system) : system(system) {}
  virtual ~Emitter() {}
  
  // эмитер выгружает какое то количество частиц в буфер
  virtual void update(const size_t &time) = 0;
  
  // потребуется ли ему что нибудь еще?
  // здесь может потребоваться количество частиц которое мы хотим  выпустить за одну секунду, для чего? 
// protected:
//   ParticleSystem* system;
};
// во всех эммитерах потребуется указатель на буфер + атомарная переменная для мультитрединга
// эмитеры будут разными: некоторые эмитеры, будут работать только тогда когда они в зоне видимости
// как такие эмитеры должны действовать чтобы восстановить состояние до необходимого?
// запомнить видимый ли он, ссуммировать время, а потом выпустить частицы по этому ссуммированному времени, жизнеспособно

// у нас будут "одноразовые" эмитеры, то есть после выпуска всех частиц их нужно будет удалять
// как узнать когда их нужно удалить? тут сложно что то придумать помимо virtual bool canBeDeleted();
// ну и да подобные эмитторы должны быть маленькими, то есть выпускать не очень много частиц и желательно только в видимости игрока
// в видимости игрока? неплохо было бы сразу проверить, то есть нужен фрустум
// эмиттеров будет много разных, как их правильно создать и удалить? в общем нужен какой-то контейнер

class SmallEmitter : public Emitter {
public:
//   SmallEmitter(ParticleSystem* system) : Emitter(system) {}
  virtual ~SmallEmitter() {}
  
  virtual bool canBeDeleted() const = 0;
};

#endif
