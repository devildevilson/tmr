#ifndef SIMULATION_PART_H
#define SIMULATION_PART_H

// что такое контекст физики?
// по идее это буферы с различными данными
// общими для всей физики: положения, тела, формы
// у физики гораздо сильнее выражена зависимость 
// между каждыми simulation_part, они составляют группы 
// например броад фаза (перевычисляем aabb, передобавляем их в структуру)
// для этого мы можем сделать две вещи: целая броадфаза - отдельный simulation_part
// или корячить какой то крупный контекст
// в первом случае удобно создавать simulation_part нужные именно броадфазе
// но не очень понятно как контролировать что происходит между фазами
// (хотя в другом случае неочень понятно, нужно сделать так чтобы фазы создать было легко)
// как быть с шагом симуляции? мне нужно разделить некоторые simulation_part друг от друга
// у одних будет константное время обновления, другие будут обновляться каждый кадр
// так? ну судя по тому что у меня уже написано так
// в simulation_part должны быть только вычисления
// такой тип построения физики хорош, когда мы точно знаем
// все входные данные и количество выходных (что в физике не всегда очевидно)
// плох тем, что мы в любой точке выполнения программы можем захотеть посчитать какой нибудь луч
// но нам придется ждать выполнения физики в текущем кадре, 
// но сомневаюсь что это такая уж большая проблема

// что еще? физика требует постоянного обновления по умолчанию
// поэтому, к сожалению, тут не сократить количество данных
// как мы это делаем в оптимизерах
// судя по прошлой физике нам нужно множество всяких массивов с индексами
// можно ли как то избежать нагромождения всякой не нужной фигни?
// в булете используется множество массивов

#include <cstddef>
#include "physics_core.h"

namespace devils_engine {
  namespace physics {
    namespace core {
      template <typename T>
      class simulation_part {
      public:
        virtual ~simulation_part() {}
        virtual void begin(T* ctx) = 0;
        virtual void process(T* ctx, const size_t &delta_time) = 0;
        virtual void clear() = 0;
      };
      
      template <typename T>
      class interpolate_part {
      public:
        virtual ~interpolate_part() {}
        virtual void begin(T* ctx) = 0;
        virtual void process(T* ctx, const core::scalar &alpha) = 0;
        virtual void clear() = 0;
      };
    }
  }
}

#endif
