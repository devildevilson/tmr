#ifndef SKILL_COMPONENT_H
#define SKILL_COMPONENT_H

#include "Type.h"
#include "Interaction.h"
#include "Attributes.h"
#include "Utility.h"
#include "AttributesComponent.h"

#include <vector>

namespace yacs {
  class entity;
}

// как раз таки этот компонент должен по идее приводить в движение взаимодействие между энтити
// ко всему прочему служить интерфейсом для ИИ взаимодействий
// тут наверное единственый важный метод - useSkill() (название придумать!)
// как мне определить умения применяемые челиками?
// 100% здесь будет простое умение атака оружием, "attack" берет из текущего оружия данные
// и запускает интеракцию, она находит энтити и применяет к ним функцию, в функции
// все эффекты атаки вычисляются, резистятся а затем передаются другому энтити
// примерно так выглядит обычная атака
// сложнее дела обстоят с заклинаниями, "fire_ball" мало того что скорее всего должен сначала скастоваться
// он еще должен заменить активное оружее после каста, или не заменить?
// состояния в оружии имеют неприятное свойство что мне нужно добавлять новое оружее
// по поводу и без, можно вполне сделать систему временного оружия, то есть добавляем
// указатель в инвентарь, это оружие выше по приоритету, смена этого оружия развеет заклинание
// ну это уже больше похоже на правду, как в этом случае использовать две руки?
// скорее всего никак, нужно просто сделать специальную анимацию
// то есть дефолтное состояние обе руки наизготовке, при стрельбе одна рука всегда использована
// а вторая еще нет, если выстрелили несколько раз то задуваем дым и снова обе руки на изготовке
// это выход, как проветить несколько выстрелов (мне это пригодится еще и для анимации портретов)
// у игрока проверить несложно, замечаем время когда мы использовали тот или иной скилл
// а ну у всех несложно проверить, как использовать эту информацию? мне нужно правильно сменить анимацию
// если сменять анимацию извне, то тогда изи
// нужно еще возвращать состояние абилки, состояние можно вернуть по состоянию в стейтконтроллере
// чендже стейт флаг видимо нужен еще, может и не нужен даже
// просто форсим изменение состояния, и ждем какое то время
// из чего у нас состоит абилка? чаще всего это проджектайл (ну или что то очень на него похожее)
// то есть: время каста (может быть ноль), смена оружия (может быть несколько зарядов), атака
// (собственно используем оружее, пускаем проджектайл, он что-то делает), конец
// или: время каста, улучшение оружия (как? ), атака (модифицированная,
// например в дополнение к обычной атаке запускаем еще и проджектайлы какие-нибудь), конец
// с другой стороны в крупных движках все делается через всякие виртуальные функции типа
// onStrike, onCollide и прочие, почему мне это неподходит? потому что это не очень удобно
// использовать например с lua, (ну то есть можно сделать объект с переопределенными
// функциями и подать туда функции из луа, но зачем, когда можно сделать то же самое сразу)
// значит идея добавить еще одно оружее (ну или по крайней мере пачку данных) для того
// чтобы описать взаимодействие после использования основного оружия
// вот вообще иной подход: любой абилка - энтити, собираемый из разных частей
// части например такие: система таргета, система интеракции, какие то еще вещи (передатчик эффектов?)
// таким образом гораздо легче собрать любой скилл так чтобы он более мнее меня устраивал при любых обстоятельствах
// почему энтити? так и сяк придется создавать уникальный объект каждой абилке (например, для взаимодействий)
// как обновлять? мне нужно обновить в основном только компонент взаимодействия,
// и то только в случае обычной милишной атаки, можно наверное будет сделать обновление изнутри
// то есть передать необходимые данные энтити
// как решить с помощью этого мои проблемы? просто создавать несколько энтити для атаки например
// то есть атака, затем чекаем наличие модификатора, создаем, далее по списку следующий модификатор
// значит появляется понятие модификатор, что это? тип энтити (абилки) + настройки, которые мы применяем дополнительно
// к существующей абилке
// создание энтити в данный момент у меня происходит в одном потоке, может ли это стать проблемой?
// когда создавать энтити? желательно это делать конечно в текущем кадре, то есть до вычисления физики
// в этом случае производительность может пристрелиться
// с другой стороны в кадре будет создано (или удалено) от силы штук 10 абилок, это врядли сильно ухудшит ситуацию
// у нас есть однокадровые абилки, но их все равно нужно както создать,
// при создании абилок может быть много использования new, нужно задизайнить так чтобы этого не было
// (например, передавать эффект компонент от родительского объекта, каким-то образом переработать некоторые классы, подумать короч)
// запустить создание абилок параллельно чему нибудь (чему вот только, поиску пути?, короч нужно доделать параллельное создание энтити)
// так как выглядит теперь у нас это дело: вызываем например "melee_attack" (название изменить наверное),
// время каста никакого нет, поэтому сразу создаем энтити (сферическая атака, наследуем положение, эффекты и аттрибуты видимо)
// когда удалить?, а главное как определить закончили ли мы атаку или еще нет? анимация и звук?
// конец определить можно только через конец взаимодействия, анимация и звук запускающего абилку должны быть известны заранее
// дополнительные эффекты должны быть записаны в энтити
// этот же подход нужно использовать при использовании предметов
// также очень хороший ответ здесь: https://gamedev.stackexchange.com/questions/46819/making-characters-skills-and-abilities-as-commands-good-practice

// короч в итоге: каждая абилка - энтити, мы ее собираем из разных свойств
// для того чтобы придать атаке дополнительный модификатор, вызываем абилки последовательно
// некоторые абилки заменяют текущее оружее на временное, которое используется по умолчанию
// энтити абилки должны также быть в итемах, так мы будем делать разные способы взаимодействий
// абилки будут наследовать некоторые свойства родительского энтити, для того чтобы правильно посчитать взаимодействие
// следить за абилками будем по одному из их компонентов
// для того чтобы это в будущем все работало супербыстро нужно сделать параллельный yacs
// (впринципе это скорее всего и так будет работать достаточно быстро, кажется из всех возможных компонентов,
// только непосредственно в энтити используется new (unordered_map) + в интеракции)
// какие у абилки свойства? интеракция, аттрибуты (наследуемо), эффекты которые применяются (наследуемо),
// положение (наследуемо), физический компонент, анимация, графика, возможно он и сам должен создавать какие-нибудь энтити
// возможно разное поведение при удалении энтити, время жизни

// где изменять состояния? при применении абилки? вообще логично
// ладно для начало нужно разобраться как создавать энтити
// как я уже ранее говорил, нужен специальный фактори, который я могу собрать в json
//

// в общем нужно переделать все
// так как энтити создается с помощью компонентов, то и создание должно быть компонентно
// то есть мне нужно подойти с другой стороны к этому процессу
// нужно создать энтити типы, в которых будут разные компоненты отвечать за создание разных компонентов
// у меня сейчас есть наработка с атрибутами, мне нужно так же сделать все остальное
// так же создание энтити можно разделить на два типа, когда есть родительский энтити, и когда его нет
// на основе этого легко можно сделать паттерн
// virtual void createComponent(const yacs::entity*, yacs::entity*, yacs::entity*) const = 0;

// TODO: интеракции нужно бы переделать для использования с физическим компонентом

struct Ability {
  const AbilityType* type;

  yacs::entity *ent;
  Interaction *inter;
  size_t currentTime;
};

class AbilitySystemComponent {
public:

  bool cast(const Type &id); // возможно нужно передать сюда еще таргет
  std::pair<const AbilityType*, size_t> casting_ability() const;
  void cancel_casting();

  size_t casted(const Type &id) const;  // возвращает время до окончания каста

private:
  yacs::entity* obj;
  
  // интеракции, инвентарь
  // энтити абилок
  std::vector<Ability> abilities;

  const AbilityType* type;
  size_t timePoint;
  
  InventoryComponent* inventory;
};

#endif //SKILL_COMPONENT_H
