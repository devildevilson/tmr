#ifndef EVENT_TASK_SYSTEM_H
#define EVENT_TASK_SYSTEM_H

#include "Engine.h"
#include "TypelessContainer.h"
#include "Type.h"
#include "ThreadPool.h"

#include <vector>
#include <mutex>

class EventComponent;

namespace yacs {
  class Entity;
}

struct DelayedEvent {
  EventComponent* ptr;
  Type type;
  void* additionalData;
  void* userData;
};

// мы должны откладывать выполнение определенных эвентов
// причем некоторые эвенты мы можем выполнить во время отрисовки и сна
class EventTaskSystem : public Engine {
public:
  struct CreateInfo {
    dt::thread_pool* pool;
  };
  EventTaskSystem();
  ~EventTaskSystem();
  
  void update(const uint64_t & time) override;
  
  // нужно добавить отложенный вызов эвентов какого то объекта, наверное это дело будем вызывать раньше систем
  void delayEvent(const DelayedEvent &ev);
  
  // тут еще должна быть функция которая создаст энтити, для этого нам нужен какой-нибудь фактори
  // это пригодится для создания объектов при выстреле
  
  // это наверное в самом конце
  void destroyEntity(yacs::Entity* ent);
  
  template<typename T, typename... Args>
  T* addSystem(Args&&... args) {
    T* ptr = systemContainer.addStage<T>(std::forward<Args>(args)...);
    systems.push_back(ptr);
    return ptr;
  }
private:
  dt::thread_pool* pool;
  
  std::mutex mutex;
  std::vector<DelayedEvent> events;
  
  // тут скорее всего все равно будут несколько систем дополнительно
  StageContainer systemContainer;
  std::vector<Engine*> systems;
};

// сюда же нужно будет добавить указатели на оставшиеся компоненты для их обновления
// тут у нас должен быть широкий спектр задач, прежде всего это игровая логика
// то есть мы должны добавлять сюда какие то функции которые мы хотим обработать в конце
// например, создание и удаление объектов

// основная задача заключается в том чтобы задачи по возможности обрабатывались многопоточно
// есть явно немногопоточные задачи, например, создание удаление объектов (возможно я сделаю когда нибудь многопоток в этом случае)
// есть задачи которые по идее можно сделать в многопотоке, например, взаимодействие с атрибутами
// достаточно лишь ввести некий буффер изменений атрибутов, туда складывать все изменения, а в следующем кадре их вычислить
// главная запара возникает в тот момент когда у нас появляется потребность в запуске эвентов у другого объекта
// стоп, если нам нужно лишь ограничить запуск эвентов то можно просто добавить в эвент компонент мьютекс
// тогда внутри объекта гарантировано будут работать все эвенты в одном потоке
// чем это мне может угрожать? мьютекс считается долгой штукой, да но нагрузка у меня будет чаще всего меньше чем количество объектов
// (я имею ввиду что скорее всего ее будет сильно мало в одном кадре + наверняка ее можно будет балансировать)
// мьютекс будет бессмысленно запускаться в ии компоненте, это верно, возможно стоит просто сделать безопасный вызов и не безопасный
// мьютекс не спасет от изменения глобального состояния + не гарантирует атомарность изменения локального состояния
// решение заключается в том чтобы не использовать глобальные состояния (ну или проектировать строгие интерфейсы ко всем глобальным состояниям)
// локальные состояния действительно сложнее, ситуации могут быть разными, но чаще всего мне просто нужно будет и локальные вещи правильно спроектировать
// например, атака влечет за собой изменение состояния атакуемого, это значит, что изменение состояния нужно куда то записать прежде чем обрабатывать
// атака в свою очередь может повлечь за собой реакцию ввиде возвращения урона, для этого мы в функции эвента должны будет обратиться к глобальной системе,
// добавить вызов этого эвента, и видимо в следующем кадре вычислить уже этот эвент
// таким образом эвенты будут запускаться строго под мьютексом, ненужно париться на счет пар, 
// нужно продумать лишь интерфейсы к которым могут обратиться функции эвентов

#endif
